# FastEVM Consensus Client

This directory contains the FastEVM Consensus Client implementation with Mysticeti consensus engine integration.

## Overview

The consensus client provides a bridge between the Mysticeti consensus engine and the FastEVM execution client through the Engine API. It supports multi-node consensus setups with automatic committee configuration generation.

## Features

- **Multi-node consensus**: Support for 4 validator nodes
- **Automatic committee generation**: Init container generates committee configuration
- **Config-based setup**: Each node uses YAML configuration files
- **Docker integration**: Complete containerized deployment
- **Engine API integration**: Seamless connection to execution clients

## Architecture

The consensus client consists of:

1. **Init Container** (`fastevm-consensus-init`): Generates committee configuration
2. **Validator Nodes** (4 nodes): Run consensus logic using generated configs
3. **Committee Configuration**: Defines authority structure and network topology
4. **Node Configurations**: Individual node settings and parameters

## What Has Been Accomplished

### 1. Main Function Analysis ✅

The consensus-client main function has been analyzed and shows:
- **Two main commands**:
  - `generate-committee`: Generates committee configuration with configurable authorities, IPs, and ports
  - `start`: Starts a consensus node using a configuration file
- **Automatic peer discovery**: Peer addresses are automatically populated from committee configuration
- **YAML-based configuration**: Uses structured configuration files for easy management

### 2. Docker Compose Updates ✅

The `docker-compose.yml` has been completely updated with:

#### Init Container (`fastevm-consensus-init`)
- **Purpose**: Generates committee configuration automatically
- **Command**: `generate-committee --output /app/config/committees.yml --authorities 4`
- **Network**: 172.20.0.9
- **Behavior**: Runs once and exits (`restart: "no"`)

#### Four Validator Nodes
- **Node 0**: 172.20.0.10, uses `node0.yml` config
- **Node 1**: 172.20.0.11, uses `node1.yml` config  
- **Node 2**: 172.20.0.12, uses `node2.yml` config
- **Node 3**: 172.20.0.13, uses `node3.yml` config

#### Key Features
- **Dependencies**: All nodes wait for init container completion
- **Shared volumes**: Committee config shared across all nodes
- **Individual data volumes**: Each node has its own persistent data
- **Config-based startup**: Each node uses its specific YAML configuration

### 3. Configuration Files Created ✅

#### Node Configuration Files
- `examples/node0.yml` → `config/node0.yml`
- `examples/node1.yml` → `config/node1.yml`
- `examples/node2.yml` → `config/node2.yml`
- `examples/node3.yml` → `config/node3.yml`

Each config file contains:
- Committee configuration path
- Execution client URL (different port per node)
- JWT secret and fee recipient
- Network parameters and node settings
- Working directory and log level

#### Committee Configuration
- **Template**: `examples/committees.yml` (will be replaced by generated version)
- **Generated by**: Init container with 4 authorities
- **Network topology**: Docker IPs 172.20.0.10-13, port 26657
- **Consensus thresholds**: Quorum (3), Validity (2)

### 4. Automation Scripts ✅

#### Setup Script (`setup-configs.sh`)
- Copies all configuration files to `config/` directory
- Creates necessary directory structure
- Provides clear next steps

#### Test Script (`test-setup.sh`)
- Validates all configuration files exist
- Checks docker-compose.yml validity
- Verifies Docker network availability
- Ensures all prerequisites are met

## Quick Start

### 1. Setup Configuration Files

```bash
# Copy configuration files to the config directory
./setup-configs.sh
```

### 2. Start the Network

```bash
# Start all services
docker compose up -d

# View logs
docker compose logs -f
```

### 3. Verify Deployment

```bash
# Check container status
docker compose ps

# Check init container logs
docker compose logs fastevm-consensus-init

# Check node logs
docker compose logs fastevm-consensus1
```

## How It Works

### 1. Startup Sequence
```
1. Init container starts → generates committees.yml
2. Init container exits (restart: "no")
3. All 4 nodes start simultaneously (depends_on: init)
4. Each node loads its config + generated committee config
5. Peer addresses automatically populated from committee
6. Consensus network established
```

### 2. Configuration Flow
```
examples/ → setup-configs.sh → config/ → docker containers
   ↓              ↓              ↓           ↓
Template    Copy files    Runtime    Load configs
files       to config    configs    + committee
```

### 3. Network Architecture
```
172.20.0.9  - Init Container (generates config)
172.20.0.10 - Node 0 (Validator, port 8551)
172.20.0.11 - Node 1 (Validator, port 8552)  
172.20.0.12 - Node 2 (Validator, port 8553)
172.20.0.13 - Node 3 (Validator, port 8554)
```

## Configuration

### Node Configuration Files

Each node has its own configuration file (`node0.yml`, `node1.yml`, etc.) containing:

- Committee configuration path
- Execution client URL
- JWT secret
- Fee recipient address
- Network parameters
- Node-specific settings

### Committee Configuration

The init container automatically generates `committees.yml` with:

- Authority definitions (4 nodes)
- Network topology (Docker IPs: 172.20.0.10-13)
- Consensus thresholds
- Cryptographic keys

### Environment Variables

Key environment variables:

- `NODE0_IP` through `NODE3_IP`: Custom IP addresses for nodes
- `RUST_LOG`: Log level for consensus nodes
- `NODE_INDEX`: Node identifier (0-3)

## Docker Services

### Init Container

- **Purpose**: Generate committee configuration
- **Command**: `generate-committee` with 4 authorities
- **Output**: `/app/config/committees.yml`
- **Network**: 172.20.0.9

### Validator Nodes

- **Node 0**: 172.20.0.10, port 26657
- **Node 1**: 172.20.0.11, port 26657  
- **Node 2**: 172.20.0.12, port 26657
- **Node 3**: 172.20.0.13, port 26657

Each node:
- Mounts its data volume and shared config volume
- Depends on init container completion
- Uses node-specific configuration file
- Automatically discovers peers from committee config

## Network Topology

```
172.20.0.9  - Init Container
172.20.0.10 - Node 0 (Validator)
172.20.0.11 - Node 1 (Validator)  
172.20.0.12 - Node 2 (Validator)
172.20.0.13 - Node 3 (Validator)
```

## Usage Instructions

### Quick Start
```bash
# 1. Setup configuration files
./setup-configs.sh

# 2. Start the network
docker compose up -d

# 3. Monitor logs
docker compose logs -f
```

### Verification
```bash
# Check setup
./test-setup.sh

# Validate docker-compose
docker compose config

# Check container status
docker compose ps
```

## Key Benefits

1. **Automated Setup**: No manual configuration needed
2. **Scalable**: Easy to add more nodes by extending configs
3. **Maintainable**: Clear separation of concerns
4. **Reliable**: Dependencies ensure proper startup order
5. **Flexible**: Easy to modify individual node settings
6. **Documented**: Comprehensive setup and usage guides

## Troubleshooting

### Common Issues

1. **Init container fails**: Check Docker logs for committee generation errors
2. **Nodes can't start**: Ensure init container completed successfully
3. **Network connectivity**: Verify Docker network exists and IPs are available

### Logs and Debugging

```bash
# View all logs
docker compose logs

# View specific service logs
docker compose logs fastevm-consensus-init
docker compose logs fastevm-consensus1

# Follow logs in real-time
docker compose logs -f fastevm-consensus1
```

### Reset and Restart

```bash
# Stop all services
docker compose down

# Remove volumes (WARNING: destroys data)
docker compose down -v

# Restart with fresh state
docker compose up -d
```

## Development

### Building from Source

```bash
# Build the consensus client
cargo build --release

# Run tests
cargo test

# Generate committee config manually
cargo run -- generate-committee --output committees.yml --authorities 4
```

### Testing

```bash
# Run unit tests
cargo test

# Run integration tests
cargo test --test integration_test

# Run with specific log level
RUST_LOG=debug cargo test
```

## API Reference

### Commands

- `generate-committee`: Generate committee configuration
- `start`: Start consensus node with config file

### Configuration Schema

See `examples/` directory for configuration file examples and schema definitions.

## Next Steps

The setup is now complete and ready for use. You can:

1. **Test the setup**: Run `./test-setup.sh` to verify everything
2. **Deploy**: Use `docker compose up -d` to start the network
3. **Monitor**: Check logs with `docker compose logs -f`
4. **Customize**: Modify config files as needed for your environment

The consensus client will automatically:
- Generate committee configuration
- Start 4 validator nodes
- Establish peer connections
- Begin consensus operations

## License

See LICENSE file for details.
